#![cfg(any(target_arch = "x86_64", target_arch = "x86"))]
#![no_std]
extern crate aes;
extern crate ctr;
extern crate stream_cipher;

use aes::block_cipher_trait::generic_array::GenericArray;
use aes::{Aes128, Aes256};
use stream_cipher::StreamCipherCore;

type Aes128Ctr = ctr::Ctr128<Aes128>;
type Aes256Ctr = ctr::Ctr128<Aes256>;

macro_rules! impl_test {
    ($name:ident, $cipher:ty, $data:expr) => {
        #[test]
        fn $name() {
            let key = include_bytes!(concat!("data/", $data, ".key.bin"));
            let key = GenericArray::from_slice(key);
            let iv = include_bytes!(concat!("data/", $data, ".iv.bin"));
            let iv = GenericArray::from_slice(iv);
            let plaintext = include_bytes!(
                concat!("data/", $data, ".plaintext.bin"));
            let ciphertext = include_bytes!(
                concat!("data/", $data, ".ciphertext.bin"));

            let mut mode = <$cipher>::new(key, iv);
            let mut pt = plaintext.to_vec();
            {
                let (a, t) = pt.split_at_mut(17);
                let (b, c) = t.split_at_mut(5);
                mode.apply_keystream(a);
                mode.apply_keystream(b);
                mode.apply_keystream(c);
            }
            assert_eq!(pt, &ciphertext[..]);
        }
    }
}

// Random tests generated by OpenSSL
impl_test!(aes128_ctr, Aes128Ctr, "ctr_aes128");
impl_test!(aes256_ctr, Aes256Ctr, "ctr_aes256");
